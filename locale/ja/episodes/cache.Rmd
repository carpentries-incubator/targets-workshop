---
title: 'ワークフローオブジェクトの読み込み'
teaching: 10
exercises: 2
---

```{r}
#| label: setup
#| echo: FALSE
#| message: FALSE
#| warning: FALSE
library(targets)
source("files/lesson_functions.R")
```

:::::::::::::::::::::::::::::::::::::: questions 

- ワークフローはどこで実行されますか？
- ワークフローによって作成されたオブジェクトをどのように検査できますか？

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- `targets` がワークフローを実行する場所とその理由を説明する
- ワークフローによって作成されたオブジェクトをRセッションにロードできるようにする

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: instructor

エピソードの概要: 作成したオブジェクトにアクセスする方法を示す

:::::::::::::::::::::::::::::::::::::

## ワークフローはどこで実行されますか？

私たちはちょうど最初のワークフローを実行しました。
今、出力を見たいと思うでしょう。
しかし、オブジェクトの名前（例えば `penguins_data`）を呼び出すだけではエラーが発生します。
```{r}
#| label: error
penguins_data
```

ワークフローの結果はどこにありますか？

::::::::::::::::::::::::::::::::::::: instructor

- `targets` が別のRセッションで実行されるという概念を強調するために、`penguins_data` を実行しようとしてエラーになるふりをして驚きを装い、それを教育的な瞬間として使用することができます（エラーは教育の一部です！）。

::::::::::::::::::::::::::::::::::::::::::::

ワークフローの結果が見えないのは、`targets` が**ワークフローを別のRセッションで実行する**ためであり、そのセッションと対話することができないからです。
これは再現性のためです---ワークフローによって作成されたオブジェクトは、プロジェクト内のコードのみに依存すべきであり、Rに対してインタラクティブに与えたコマンドには依存すべきではありません。

幸いにも、`targets` にはワークフローによって作成されたオブジェクトを現在のセッションにロードするために使用できる2つの関数、`tar_load()` と `tar_read()` があります。
これらがどのように機能するか見てみましょう。

## tar_load()

`tar_load()` は、ワークフローによって作成されたオブジェクトを現在のセッションにロードします。
最初の引数はロードしたいオブジェクトの名前です。
これを使用して `penguins_data` をロードし、`summary()` でデータの概要を取得しましょう。

```{r}
#| label: targets-run-hide
#| echo: FALSE
# ワークフローの各インスタンスは隔離されているため、Rmdをビルドするときに再実行が必要です
plan_1_dir <- make_tempdir()
pushd(plan_1_dir)
write_example_plan("plan_1.R")
tar_make(reporter = "silent")
penguins_csv_file_hide <- tar_read(penguins_csv_file)
penguins_data_hide <- tar_read(penguins_data)
popd()
```

```{r}
#| label: targets-load
#| echo: [2, 3]
pushd(plan_1_dir)
tar_load(penguins_data)
summary(penguins_data)
popd()
```

`tar_load()` は**副作用**---望むオブジェクトを現在のRセッションにロードするために使用されます。
実際には値を返しません。

## tar_read()

`tar_read()` は、ワークフローによって作成されたオブジェクトを取得するために使用される点では `tar_load()` と似ていますが、`tar_load()` とは異なり、それらを直接出力として返します。

`penguins_csv_file` で試してみましょう。

```{r}
#| label: targets-read-show
#| echo: [2]
pushd(plan_1_dir)
tar_read(penguins_csv_file)
popd()
```

`penguins_csv_file` の内容がすぐに表示されます。
しかし、それは環境にロードされていません。
今 `penguins_csv_file` を実行しようとすると、エラーが発生します：

```{r}
#| label: error-2
penguins_csv_file
```

## どの関数をいつ使用するか

`tar_load()` はオブジェクトをロードしてそれらを操作したいときにより便利です。
`tar_read()` はオブジェクトを即座に検査したいときにより便利です。

## targets キャッシュ

Rセッションを終了し、再起動して `tar_load()` または `tar_read()` を使用すると、ワークフローオブジェクトをまだロードできることに気づくでしょう。
言い換えれば、ワークフローの出力は**Rセッション間で保存**されています。
これはどのように可能なのでしょうか？

プロジェクトに新しいフォルダ `_targets` が現れたことに気づいたかもしれません。
これは**targets キャッシュ**です。
ワークフローの出力すべてが含まれています。これにより、Rを終了して再起動した後でもワークフローによって作成されたターゲットをロードできるのです。

**キャッシュの内容を手動で編集してはいけません**（1つの例外を除く）。
そうすると、分析の再現性が失われます。

このルールの唯一の例外は、`_targets/user` という特別なサブフォルダです。
このフォルダはデフォルトでは存在しません。
必要であれば作成し、任意のものを中に入れることができます。

一般的に、`_targets/user` はデータや出力のようなコードではないファイルを保存するのに適しています。

もし `_targets/user` に保持する必要があるものが何もない場合、単に `_targets` フォルダ全体を削除することでワークフローを「リセット」することが可能です。
もちろん、これはすべてを再実行する必要があることを意味するため、軽率に行わないでください！

::::::::::::::::::::::::::::::::::::: keypoints 

- `targets` のワークフローは別の非対話型Rセッションで実行されます
- `tar_load()` はワークフローオブジェクトを現在のRセッションにロードします
- `tar_read()` はワークフローオブジェクトを読み取り、その値を返します
- `_targets` フォルダはキャッシュであり、一般的には手動で編集すべきではありません

::::::::::::::::::::::::::::::::::::::::::::
