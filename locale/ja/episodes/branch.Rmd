---
title: 'ブランチング'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- すべてを入力せずに多くのターゲットをどのように指定できますか？

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- ブランチングを使用してターゲットを指定できるようにする

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: instructor

エピソードの概要: ブランチングの使用方法を示す

:::::::::::::::::::::::::::::::::::::

```{r}
#| label: setup
#| echo: FALSE
#| message: FALSE
#| warning: FALSE
library(targets)
library(tarchetypes)
library(broom)
source("files/lesson_functions.R")

# Increase width for printing tibbles
options(width = 140)
```

## なぜブランチングなのか？

`targets` の大きな強みの一つは、**ブランチング**と呼ばれる、単一のコード行から多くのターゲットを定義できる能力です。
これは入力を省くだけでなく、タイプミスの可能性が減るため、**エラーのリスクも低減**します。

## ブランチングの種類

ブランチングには、**動的ブランチング**と**静的ブランチング**の二種類があります。
「ブランチング」とは、ターゲットを作成する方法（「パターン」）を単一に指定し、`targets` がそれから複数のターゲット（「ブランチ」）を生成するという考え方を指します。
「動的」とは、パターンから生成されるブランチが事前に定義されている必要がなく、コードの結果として動的に生成されることを意味します。

このワークショップでは、**動的ブランチングのみ**を扱います。静的ブランチングは[メタプログラミング](https://books.ropensci.org/targets/static.html#metaprogramming)の使用を必要とするため、これは高度なトピックです。どちらをいつ使用するか（または両方の組み合わせ）についての詳細は、[`targets` パッケージマニュアル](https://books.ropensci.org/targets/dynamic.html)を参照してください。

## ブランチングなしの例

これがどのように機能するかを理解するために、`palmerpenguins` データセットの分析を続けましょう。

**私たちの仮説は、くちばしの深さがくちばしの長さとともに減少するということです。**
この仮説を線形モデルで検証します。

例えば、これはくちばしの長さに依存するくちばしの深さのモデルです：

```{r}
#| label: example-lm
#| eval: FALSE
lm(bill_depth_mm ~ bill_length_mm, data = penguins_data)
```

これをパイプラインに追加できます。すべての種を区別せずに結合しているため、`combined_model` と呼びます：

```{r}
#| label = "example-lm-pipeline-show",
#| eval = FALSE,
#| code = readLines("files/plans/plan_4.R")[2:19]
```

```{r}
#| label: example-lm-pipeline-hide
#| echo: false
plan_4_dir <- make_tempdir()
pushd(plan_4_dir)
write_example_plan("plan_3.R")
tar_make(reporter = "silent")
write_example_plan("plan_4.R")
tar_make()
popd()
```

モデルを見てみましょう。`broom` パッケージの `glance()` 関数を使用します。これは base R の `summary()` とは異なり、出力をティブル（データフレームの tidyverse 相当）として返します。後で見るように、これは下流の分析に非常に便利です。

```{r}
#| label: example-lm-pipeline-inspect-show
#| eval: true
#| echo: [2, 3, 4]
pushd(plan_4_dir)
library(broom)
tar_load(combined_model)
glance(combined_model)
popd()
```

小さな *P*-値に注目してください。
これはモデルが非常に有意であることを示しているようです。

しかし、ちょっと待ってください... これは本当に適切なモデルでしょうか？ データセットには3種類のペンギンがいることを思い出してください。くちばしの深さと長さの関係が**種によって異なる**可能性があります。

おそらく、種に対するパラメータを追加するモデルや、種とくちばしの長さの相互作用効果を追加するモデルなど、いくつかの代替モデルをテストする必要があります。

これでワークフローがより複雑になっています。これは**ブランチングなし**でのそのような分析のワークフローの例です（`packages.R` に `library(broom)` を追加することを忘れないでください）：

```{r}
#| label = "example-model-show-1",
#| eval = FALSE,
#| code = readLines("files/plans/plan_5.R")[2:31]
```

```{r}
#| label: example-model-hide-1
#| echo: false
plan_5_dir <- make_tempdir()
pushd(plan_5_dir)
# simulate already running the plan once
write_example_plan("plan_4.R")
tar_make(reporter = "silent")
write_example_plan("plan_5.R")
tar_make()
popd()
```

モデルの一つのサマリーを見てみましょう：

```{r}
#| label: example-model-show-2
#| eval: true
#| echo: [2]
pushd(plan_5_dir)
tar_read(species_summary)
popd()
```

この方法でパイプラインを書くと機能しますが、繰り返しが多くなります。各モデルのサマリー統計量を取得するたびに `glance()` を呼び出さなければなりません。
さらに、各サマリータゲット（`combined_summary` など）は明示的に名前が付けられ、手動で入力されています。
タイプミスをして間違ったモデルがサマリーされるのはかなり簡単です。

## ブランチングを使用した例

### 最初の試み

**動的ブランチング**を使用して同じプランを書く方法を見てみましょう：

```{r}
#| label = "example-model-show-3",
#| eval = FALSE,
#| code = readLines("files/plans/plan_6.R")[2:29]
```

ここで何が起こっているのでしょうか？

まず、`tar_make()` が提供するメッセージを見てみましょう。

```{r}
#| label: example-model-hide-3
#| echo: false
plan_6_dir <- make_tempdir()
pushd(plan_6_dir)
# simulate already running the plan once
write_example_plan("plan_5.R")
tar_make(reporter = "silent")
write_example_plan("plan_6.R")
tar_make()
example_branch_name <- tar_branch_names(model_summaries, 1)
popd()
```

一連の小さなターゲット（ブランチ）があり、それぞれが `r example_branch_name` のように名前付けされ、その後に全体の `model_summaries` ターゲットがあります。
これはブランチングを使用してターゲットを指定した結果です：小さなターゲットそれぞれが全体のターゲットを構成する「ブランチ」です。
`targets` は、事前にどれだけのブランチが存在するか、またそれらが何を表しているかを知らないため、数字と文字の一連（「ハッシュ」）を使用して各ブランチに名前を付けます。
`targets` は各ブランチを一つずつビルドし、それらを全体のターゲットに結合します。

次に、ワークフローがどのように設定されているか、モデルの定義から詳しく見てみましょう：

```{r}
#| label = "model-def",
#| code = readLines("files/plans/plan_6.R")[14:22],
#| eval = FALSE
```

ブランチングなしのバージョンとは異なり、モデルを**リスト内**で定義しました（モデルごとに一つのターゲットではなく）。
これは動的ブランチングが `base::apply()` や [`purrrr::map()`](https://purrr.tidyverse.org/reference/map.html) のループ方法に似ているためです：リストの各要素に関数を適用します。
したがって、ループの入力としてリストを準備する必要があります。

次に、ターゲット `model_summaries` をビルドするコマンドを見てみましょう。

```{r}
#| label = "model-summaries",
#| code = readLines("files/plans/plan_6.R")[23:28],
#| eval = FALSE
```

以前と同様に、最初の引数はビルドするターゲットの名前で、二つ目の引数はそれをビルドするコマンドです。

ここでは、`glance()` 関数を `models` の各要素に適用しています（`[[1]]` が必要なのは、関数が適用されるとき、各要素が実際にはネストされたリストであり、ネストを一層取り除く必要があるためです）。

最後に、これまで見たことのない引数 `pattern` があります。これは、このターゲットが動的ブランチングを使用してビルドされるべきことを示します。
`map` は、入力リスト（`models`）の各要素に対して関数を順次適用することを意味します。

ブランチングワークフローの構築方法を理解したので、出力を検査してみましょう：

```{r}
#| label: example-model-show-4
#| eval: FALSE
tar_read(model_summaries)
```

```{r}
#| label: example-model-hide-4
#| echo: FALSE
pushd(plan_6_dir)
tar_read(model_summaries)
popd()
```

モデルのサマリー統計量がすべて一つのデータフレームに含まれています。

しかし、一つ問題があります：**どの行がどのモデルから来たのか分かりません！** モデルのリストと同じ順序であると仮定するのは賢明ではありません。

これは動的ブランチングの動作方法によるものです：デフォルトでは、各ターゲットの由来に関する情報が出力に保持されません。

これをどう修正すれば良いでしょうか？

### 第二の試み

ブランチングパイプラインから有用な出力を得るための鍵は、各ブランチの出力に必要な情報を含めることです。
ここでは、モデルサマリーの各行に対応するモデルの種類を知りたいと考えています。
これを行うために、**カスタム関数**を書く必要があります。
`targets` を使用する際にはカスタム関数を頻繁に書く必要があるため、慣れておくと良いでしょう！

以下がその関数です。これを `R/functions.R` に保存してください：

```{r}
#| label: example-model-show-5
#| eval: FALSE
#| file: files/tar_functions/glance_with_mod_name.R
```

新しいパイプラインは以前とほぼ同じですが、今回は `glance()` の代わりにカスタム関数を使用しています。

```{r}
#| label = "example-model-show-6",
#| code = readLines("files/plans/plan_7.R")[2:29],
#| eval = FALSE
```

```{r}
#| label: example-model-hide-6
#| echo: FALSE
pushd(plan_6_dir)
write_example_plan("plan_7.R")
tar_make()
popd()
```

今回は、`model_summaries` をロードすると、各行がどのモデルに対応しているかを知ることができます（右にスクロールする必要があるかもしれません）。

```{r}
#| label: example-model-7
#| echo: [2]
#| warning: false
pushd(plan_6_dir)
tar_read(model_summaries)
popd()
```

次に、モデルに基づくくちばしの深さの予測を追加します。これはレポートでモデルをプロットする際に必要になります。
この予測は `broom` パッケージの `augment()` 関数を使用して取得できます。

```{r}
#| label: example-augment
#| echo: [2, 3]
#| eval: true
pushd(plan_6_dir)
tar_load(models)
augment(models[[1]])
popd()
```

::::::::::::::::::::::::::::::::::::: {.challenge}

## チャレンジ: ワークフローにモデル予測を追加する

`augment()` を使用してモデル予測を追加できますか？ `glance()` と同様にカスタム関数を定義する必要があります。

:::::::::::::::::::::::::::::::::: {.solution}

新しい関数を `augment_with_mod_name()` として定義します。これは `glance_with_mod_name()` と同じですが、`glance()` の代わりに `augment()` を使用します：

```{r}
#| label: example-model-augment-func
#| eval: FALSE
#| file: files/tar_functions/augment_with_mod_name.R
```

ワークフローにステップを追加します：

```{r}
#| label = "example-model-augment-show",
#| code = readLines("files/plans/plan_8.R")[2:35],
#| eval = FALSE
```

::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: {.callout}

## ブランチングのベストプラクティス

動的ブランチングは**データフレーム**（ティブル）と相性が良いように設計されています。

可能であれば、カスタム関数をデータフレームを入力として受け取り、データフレームを出力として返すように書き、必要なメタデータを列として常に含めるようにしてください。

:::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: {.challenge}

## チャレンジ: 他にどんな種類のパターンがありますか？

これまで、`pattern` 引数と組み合わせて `map()` を使用し、入力の各要素に対して関数を順次適用する単一の関数のみを使用しました。

ブランチングパターンを適用する他の方法を考えてみてください。

:::::::::::::::::::::::::::::::::: {.solution}

ブランチングパターンを適用する他の方法には以下のようなものがあります：

- crossing: 要素の組み合わせごとに一つのブランチを作成する（`cross()` 関数）
- slicing: 手動で選択した要素ごとに一つのブランチを作成する（`slice()` 関数）
- sampling: ランダムに選択した要素ごとに一つのブランチを作成する（`sample()` 関数）

ブランチングパターンの詳細については [`targets` マニュアル](https://books.ropensci.org/targets/dynamic.html#patterns) を参照してください。

::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: keypoints 

- 動的ブランチングは単一のコマンドで複数のターゲットを作成します

- ブランチの出力に必要なメタデータを含めるために、通常カスタム関数を書く必要があります 

::::::::::::::::::::::::::::::::::::::::::::::::
