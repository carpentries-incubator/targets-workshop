---
title: 'Working with External Files'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- How can we load external data?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Be able to load external data into a workflow
- Configure the workflow to rerun if the contents of the external data change

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: instructor

Episode summary: Show how to read and write external files

:::::::::::::::::::::::::::::::::::::

```{r}
#| label: setup
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

if (interactive()) {
  setwd("episodes")
}

library(targets)
library(tarchetypes)
source("files/lesson_functions.R")
```

## Treating external files as a dependency

Almost all workflows will start by importing data, which is typically stored as an external file.

As a simple example, let's create an external data file in RStudio with the "New File" menu option. Enter a single line of text, "Hello World" and save it as "hello.txt" text file in `data/`.

We will read in the contents of this file and store it as `some_data` in the workflow by writing the following plan and running `tar_make()`:

::::::::::::::::::::::::::::::::::::: {.callout}

## Save your progress

You can only have one active `_targets.R` file at a time in a given project.

We are about to create a new `_targets.R` file, but you probably don't want to lose your progress in the one we have been working on so far (the penguins bill analysis). You can temporarily rename that one to something like `_targets_old.R` so that you don't overwrite it with the new example `_targets.R` file below. Then, rename them when you are ready to work on it again.

:::::::::::::::::::::::::::::::::::::

```{r}
#| label: example-file-show-1
#| eval: FALSE
library(targets)

list(
  tar_target(
    some_data,
    readLines("data/hello.txt")
  )
)
```

```{r}
#| label: example-file-hide-1
#| echo: FALSE
tar_dir({
  fs::dir_create("data")
  writeLines("Hello World", "data/hello.txt")
  write_example_plan(chunk = "example-file-show-1")
  tar_make()
})
```

If we inspect the contents of `some_data` with `tar_load(some_data)`, it will contain the string `"Hello World"` as expected.

Now say we edit "hello.txt", perhaps add some text: "Hello World. How are you?". Edit this in the RStudio text editor and save it. Now run the pipeline again.

```{r}
#| label = "example-file-show-2",
#| eval = FALSE,
#| code = knitr::knit_code$get("example-file-show-1")
```

```{r}
#| label: example-file-hide-2
#| echo: FALSE
tar_dir({
  fs::dir_create("data")
  writeLines("Hello World", "data/hello.txt")
  write_example_plan(chunk = "example-file-show-1")
  tar_make(reporter = "silent")
  writeLines("Hello World. How are you?", "data/hello.txt")
  tar_make()
})
```

The target `some_data` was skipped, even though the contents of the file changed.

That is because right now, targets is only tracking the **name** of the file, not its contents.
We need to to tell `targets` that `"data/hello.txt"` is actually a file, not just a character string.
This can be done by setting the `format` argument of `tar_target()` to `"file"`.
Once this is set, `tar_target()` will calculate the "hash" of the file---a unique digital signature that is determined by the file's contents.
If the contents change, the hash will change, and this will be detected by `targets`.
Note this results in two targets: one that tracks the contents of the file, and one for reading in the contents of the file.

```{r}
#| label: example-file-show-3
#| eval: FALSE
library(targets)

list(
  tar_target(
    data_file,
    "data/hello.txt",
    format = "file"),
  tar_target(
    some_data,
    readLines(data_file)
  )
)
```

```{r}
#| label: example-file-hide-3
#| echo: FALSE
tar_dir({
  fs::dir_create("data")
  writeLines("Hello World", "data/hello.txt")
  write_example_plan(chunk = "example-file-show-3")
  tar_make(reporter = "silent")
  writeLines("Hello World. How are you?", "data/hello.txt")
  tar_make()
})
```

This time we see that `targets` does successfully re-build `some_data` as expected.

::::::::::::::::::::::::::::::::::::: {.challenge}

## Challenge: Use `format = "file"` with the penguins example

We didn't know about `format = "file"` yet when we started on the penguins bill analysis.

How can you use `format = "file"` to load the CSV file while tracking its contents?

:::::::::::::::::::::::::::::::::: {.solution}

```{r}
#| label = "tar-file-read-answer-show",
#| eval = FALSE,
#| code = readLines("files/plans/plan_3.R")[2:12]
```

```{r}
#| label: tar-file-read-answer-hide
#| echo: FALSE
tar_dir({
  # New workflow
  write_example_plan("plan_3.R")
  # Run it
  tar_make()
})
```

::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::

## Writing out data

Writing to files is similar to loading in files: we will use the `format = "file"` option. There is one important caveat: in this case, the second argument of `tar_target()` (the command to build the target) **must return the path to the file**. Not all functions that write files do this (some return nothing; these treat the output file is a side-effect of running the function), so you may need to define a custom function that writes out the file and then returns its path.

Let's do this for `writeLines()`, the R function that writes character data to a file. Normally, its output would be `NULL` (nothing), as we can see here:

```{r}
#| label: write-data-show-1
#| eval: false
x <- writeLines("some text", "test.txt")
x
```

```{r}
#| label: write-data-hide-1
#| echo: false
x <- writeLines("some text", "test.txt")
x
fs::file_delete("test.txt")
```

Here is our modified function that writes character data to a file and returns the name of the file (the `...` means "pass the rest of these arguments to `writeLines()`"):

```{r}
#| label: write-data-func
#| file: files/tar_functions/write_lines_file.R
```

Let's try it out:

```{r}
#| label: write-data-show-2
#| eval: false
x <- write_lines_file("some text", "test.txt")
x
```

```{r}
#| label: write-data-hide-2
#| echo: false
x <- write_lines_file("some text", "test.txt")
x
fs::file_delete("test.txt")
```

We can now use this in a pipeline. For example let's change the text to upper case then write it out again:

```{r}
#| label: example-file-show-6
#| eval: false
library(targets)
library(tarchetypes)

source("R/functions.R")

list(
  tar_target(
    data_file,
    "data/hello.txt",
    format = "file"),
  tar_target(
    hello,
    readLines(data_file)
  ),
  tar_target(
    hello_caps,
    toupper(hello)
  ),
  tar_target(
    hello_caps_out,
    write_lines_file(
      hello_caps,
      "results/hello_caps.txt"),
    format = "file"
  )
)
```

```{r}
#| label: example-file-hide-6
#| echo: false
tar_dir({
  fs::dir_create("data")
  fs::dir_create("results")
  writeLines("Hello World. How are you?", "data/hello.txt")
  write_example_plan(chunk = "example-file-show-6")
  tar_make()
})
```

Take a look at `hello_caps.txt` in the `results` folder and verify it is as you expect.

::::::::::::::::::::::::::::::::::::: {.challenge}

## Challenge: What happens to file output if its modified?

Delete or change the contents of `hello_caps.txt` in the `results` folder.
What do you think will happen when you run `tar_make()` again?
Try it and see.

:::::::::::::::::::::::::::::::::: {.solution}

`targets` detects that `hello_caps_out` has changed (is "invalidated"), and re-runs the code to make it, thus writing out `hello_caps.txt` to `results` again.

So this way of writing out results makes your pipeline more robust: we have a guarantee that the contents of the file in `results` are generated solely by the code in your plan.

::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: keypoints 

- The `format = "file"` option of `tar_target()` tells `targets` to track the contents of a file
- When you write out data, you need to use a function that writes to a file and returns its path

::::::::::::::::::::::::::::::::::::::::::::::::
